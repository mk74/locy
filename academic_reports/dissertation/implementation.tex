\section{Implementation}
\label{s:implementation}
\hspace{10pt} This section describes the implementation of the experiments and the software components involved in the project. The implementation raised practical challenges, resulting in a revisit of the design presented in the previous section. The first part of this section summarizes the challenges of establishing sensors' energy efficiency. After a description of software and hardware problems, the characteristics of experiments' results are investigated and new terms "wrong samples" and "energy efficiency levels" are defined. The second subsection presents the implementation details of the energy efficient sensing library, Locy. The derivation of the parameters for the movement detection algorithm are described and two extensions of Locy are summarized. Lastly, the work presented in this section reveals important knowledge for the project. This is concluded in the last section.

\subsection{Sensor energy measurements}
Implementing the experimental designs presented two groups of challenges. First, the designs were affected by the Android operating system and its API. A few of those issues\ (IEEE802.11 scanning, Bluetooth Low Energy API and privacy policy for video capturing) are described later. Second, the experiments involved many devices, with hardware differences that posed some challenges. The specifications of the involved mobile phones are presented in Table \ref{table:devices_differences}.
	
\begin{table}[H]
	\centering
    \begin{tabular}{| l | c | c | c |}
    \hline
      & \textbf{Google Nexus 7} & \textbf{HTC Flyer} & \textbf{HTC desire}\TBstrut  \\ \hline  
    Android & 4.3 & 3.3 &  2.3.3\TBstrut \\ \hline
  	CPU & Quad-core 1.2 GHz Cortex-A9 & 1.5 GHz Scorpion & 1 GHz Scorpion\TBstrut \\ \hline
  	Memory & 1 GB RAM & 1 GB RAM & 576 MB RAM\TBstrut \\ \hline
    Battery & Li-Ion 4325 mAh & Li-Po 4000 mAh & Li-Ion 1400 mAh\TBstrut \\ \hline
    Camera & \checkmark & \checkmark & \checkmark \\ \hline
    Microphone & \checkmark & \checkmark & \checkmark \\\hline
    IEEE 802.11 & \checkmark & \checkmark & \checkmark \\ \hline
    GPS & \checkmark & \checkmark & \checkmark \\ \hline
    Bluetooth & \checkmark & \checkmark & \checkmark\\ \hline
    Bluetooth LTE & \checkmark & - & - \\ \hline
    Accelerometer & \checkmark & \checkmark & \checkmark\\ \hline
    Gyroscope & \checkmark & - & -\\ \hline
    Magnetic Field & \checkmark & \checkmark & \checkmark\\ \hline
    Ambient Light & \checkmark & \checkmark & \checkmark\\ \hline
    Proximity & - & -& \checkmark\\ \hline
    \end{tabular}
    \caption{The differences between mobile phones involved in the experiments.}
	\label{table:devices_differences}
\end{table}	

The experimental results raised two additional challenges: Some results were perceived as invalid\ (referred to here as "wrong samples") and the valid results tended to have specific properties, referred to as "energy efficiency levels".

\subsubsection{Software problems}
\hspace{10pt} Preliminary experiments showed that \textbf{Wi-Fi scanning} was more energy-efficient than the accelerometer. This was unexpected, so the details of IEEE 802.11 scanning were further investigated. Unlike other sensors, IEEE 802.11 has many parameters: an active and passive mode, power saving mode, scan result caching, complete scanning etc. The parameters were not recorded in the Android documentation, but since they could affect the energy efficiency of the IEEE 802.11 observed in the preliminary experiments, their values had to be determined. The results of IEEE 802.11 scanning on a mobile phone were compared with the ones obtained on a laptop. Kismac \cite{kismac:kismac} was used on the laptop for a detailed list of access points, with their signal strengths. Both scanning results were compared both with a mobile and a stationary user. The parameters of IEEE 802.11 scanning on a mobile phone turned out to be identical to ones on the laptop. No caching scheme, no other energy optimization was involved\ (table \ref{table:wifiparameters}). It turned out that preliminary experiments of Wi-Fi scanning were correct: A fault with the accelerometer had caused the Wi-Fi scanning to seem more energy-efficient. After fixing the problem, Wi-Fi scanning was found to be less energy-efficient than accelerometer, as expected. It is worth noting that active IEEE 802.11 scanning is deprecated in the Android API. Passive scanning is more energy efficient than active scanning, since radio reception\ (passive scanning) usually requires 10 times less power than radio transmission\ (active scanning).

\begin{table}[H]
\centering
    \begin{tabular}{| l | c |}
    \hline
    	Characteristic & Value \\ \hline
    	Scanning mode & Passive \\ \hline
    	Power save mode & No \\ \hline
    	Caching & No \\ \hline
    	Complete scanning & Yes \\ \hline
    \end{tabular}
    \caption{The parameters of IEEE 802.11 scanning. These parameters are defaults: no specific energy optimization is involved.}
	\label{table:wifiparameters}
\end{table}

Energy efficiency may not be the highest priority in Android's design. To make accurate energy efficiency comparisons, Wi-Fi connectivity needed to be completely disabled\ (except for Wi-Fi sensor application). Disabling wireless connectivity in the main settings is not sufficient, as the Android system may switch Wi-Fi connectivity on at any point if prompted by the \textbf{Google Location Service}. To undertake valid experiments, Google Location Service had to be also disabled\ (\plotref{android_advanced_wifi}). 

\plot{android_advanced_wifi}

Another software issue was the \textbf{Bluetooth Low Energy\ (LE) API}. Bluetooth LE was designed to reduce power demands while providing the same functionality as Classic Bluetooth. Classic Bluetooth scanning on Android was therefore expected to be less energy-efficient than the Bluetooth LE. However, the Bluetooth LE API is new\ (added in Android 18) and still under development. Its current version\ (Android 18) prints out lots of information to a log file if any device is found, leading to faster battery depletion than Classic Bluetooth. However, Bluetooth LE is more energy efficient if no device is found. This observation is further analyzed in the evaluation section \plotref{bluetooth_le_api}. 

Lastly, Android imposes its \textbf{privacy policy on video capturing} applications. Video applications are required to provide a camera preview to make customers aware of the recording. This privacy policy results in higher energy demands, as the rendering a camera preview requires additional computation. As mandated by the Android API, a camera preview was added to the Camera Sensor Application.
		
\subsubsection{Hardware problems}
\hspace{10pt} Since modern mobile phones\ (e.g., Google Nexus 7) have energy-efficient hardware, \textbf{the time of 1\% battery depletion may be significant}. A test application that only continuously queried the accelerometer without performing any other operations\ (screen was switched off, Wi-Fi connectivity was off) took around half an hour to deplete 1\% of battery on a Google Nexus 7. Since online energy measurements \ref{o:measurements:online} are one of the project's objectives, the measurement method should be faster. This could be achieved by adding additional energy demands to all Sample Sensor Applications, such as by running complex computations (e.g. dividing big numbers) and discarding their results. However, such an approach could invalidate out experiments, since different Sample Sensor Applications could make use of CPU power to a different extent. Sample Sensor Applications requiring more CPU (e.g., triangulation for GPS) may be more affected by those computation demands due to e.g. CPU scheduling. The simple solution to this problem was to \textbf{always keep the screen on} for the applications. This not only significantly increases  all Sample Sensor Applications' energy demands, but can also be added uniformly to each of them without invalidating the experiments. On Google Nexus 7, this operation reduced the time of 1\% battery depletion with continuous accelerometer sensing to around 13 minutes\ (56\% shorter). 

Another hardware issue was \textbf{choosing an initial battery percentage} for the experiments\ (Table \ref{table:differentpercentage}). In the case of the Google Nexus 7, battery behavior was stable and repetitive for any chosen percentage. To reduce the time of a full experimental cycle sampling followed by charging the battery, a percentage between 98\% and 99\% was chosen. The same percentage could not be chosen for other devices, since their batteries were old and less-stable. For example, the 98\% -99\% percentage was tested for the HTC Flyer, but the results were not repetitive. The percentages for other devices were found by a \textbf{trial-and-error approach}. If the results of the experiments conducted on a given percentage were repetitive in a couple of trials, the chosen percentage was considered suitable. Also, some specific characteristics of batteries charging cycles were discovered: For the HTC Flyer, charging was much slower for the last battery percentage\ (99\%-100\%) than any other percentage. After being fully charged, the battery depleted much slower for the last percentage\ (99\%-100\%). Then, the depletion of the battery between 98\% and 99\% was immediate. This phenomenon was observed a few times. To avoid it, the percentage between 97\% and 98\% was tried and turned out more suitable for the experiments on the HTC Flyer. In the case of the HTC Desire, the charging was often not triggered when the battery level was more than 91\%. To mitigate this issue, the range from 89\% to 88\% was used for the HTC Desire. The experiments' results were repetitive and the percentages suitable for the experiments. 

\begin{table}[H]
\centering
    \begin{tabular}{| l | c |}
    \hline
    	Device & The percentage \\ \hline
    	Google Nexus 7 & 98\%-99\% \\ \hline
    	HTC Flyer & 97\%-98\% \\ \hline
    	HTC Desire & 88\%-89\% \\ \hline
    \end{tabular}
    \caption{The percentages used for energy measurement method. These percentages are different for the devices and found by trial-and-error.}
	\label{table:differentpercentage}
\end{table}

\textbf{HTC Desire has less dynamic memory}\ (576 MB RAM) than other devices\ (1 GB RAM) involved in the experiments. This affects the Camera Sensor Application. Initially, the experiment with video capturing could not be completed for HTC Desire, as there was no enough dynamic memory to encode and save the full video capture.  To alleviate this problem, the codecs were changed to H.263\ (which uses less dynamic memory when encoding video) and the video dimensions were reduced to reduce the amount of data needing to be encoded. Those parameters were standardized in the Camera Sensor Application across all devices. For consistency, the audio parameters were also standardized in the Microphone Sensor Applications for all mobile phones. Full details on the video and audio capture parameters are available in Appendices \ref{s:mediacodecs}.
			
\subsubsection{Wrong samples}
\hspace{10pt} Despite mitigating many problems with the experimental execution, some wrong samples were still produced. Statistically, the wrong samples are defined as samples whose values\ (time measurements) are \textbf{outliers}. The proportion of the wrong samples varies among devices\ (\plotref{devices_failed_samples}). The Google Nexus 7 had 100\% successful samples, so the experiments were conducted up to \textbf{3 successful samples per sensor}. Other devices had a higher proportion of wrong samples: between 20 and 30 percent for the HTC Flyer and HTC Desire. Because of that, \textbf{5 successful samples per sensor} had to be collected to complete the experiments for those devices. The wrong samples also had different characteristics for the HTC Flyer and HTC Desire. 

\plot{devices_failed_samples}
	
The wrong samples from the HTC Flyer may be characterized as \textbf{bursty errors}. \plotref{htc_flyer_bursty_error} shows that most of the wrong samples\ (9 out of 11) are grouped in two periods: 9-13 samples and 24-33. The first period includes continuous series of 4 wrong samples, whereas the second period has 6 wrong samples within 11 samples made. Each group has different characteristics, and thus, the bursty errors are difficult to detect without complete knowledge of the experiments' results, as in online energy measurements.

\plot{htc_flyer_bursty_error}

For the HTC Desire, the proportion of wrong samples varies by sensor\ (\plotref{htc_desire_failed_samples}). Some sensors such as "plain run", Bluetooth, GPS or Camera always provided successful samples. On the other hand, the light and proximity sensors had high proportions of wrong samples\ (each around 60\%). 

\plot{htc_desire_failed_samples}


\subsubsection{Energy efficiency levels}
\label{s:implementation:levels}
\hspace{10pt} After rounding valid samples' time measurements to 10 seconds, it was clear all measurements belonged to specific sets of discrete values. For the HTC Flyer, there were only three such values: 210, 240 and 270 seconds\ (Table \ref{table:discretevalues}). Those values are every 30 seconds. To simplify the valid samples' time measurements, they can be divided by this interval\ (30 seconds). The results of this operation were termed \textbf{energy efficiency levels}. For the HTC Flyer, there were three energy efficiency levels: 7, 8 and 9. A result of any experimental sample belongs to one of those levels. 
			
\begin{table}[H]
\centering
    \begin{tabular}{| c | c |}
    \hline
    	Value & Samples \\ \hline
    	210 & 4 \\ \hline
    	240 & 22 \\ \hline
    	270 & 19 \\ \hline
    	Others & 0 \\ \hline
    \end{tabular}
    \caption{Energy measurement results for HTC Flyer. There are only 3 discrete values among all samples' results.}
	\label{table:discretevalues}
\end{table}
			
Similarly with the HTC Desire, all valid samples' results belong to a set of three numbers: 150, 200 and 250 seconds. As the interval between them equals to 50, the energy efficiency levels are 3, 4 and 5. Lastly, for the Google Nexus 7, there were 9 discrete values among the all experiments results. Each value was a multiple of 60 seconds. Each initial discrete values was divided by 60 to establish its energy efficiency level. The full list of all known energy efficiency levels among devices is shown in Table \ref{table:energy_efficiency_levels}.
		
	
\begin{table}[H]
\centering
    \begin{tabular}{| c | c | c | c |}
    \hline
      Energy efficiency level & Google Nexus 7 & HTC Flyer & HTC desire \\ \hline
    Level 1 & -& - &  -\\ \hline
  	Level 2 & - & - & -\\ \hline
  	Level 3 & - & - & 150 secs\\ \hline
    Level 4 & 240 secs & - & 200 secs\\ \hline
    Level 5 & 300 secs & - & 250 secs \\ \hline
    Level 6 & - & - & - \\\hline
    Level 7 & - & 210 secs & - \\ \hline
    Level 8 & 480 secs & 240  secs & - \\ \hline
    Level 9 & 540 secs & 270 secs & - \\ \hline
    Level 10 & - & - & - \\ \hline
    Level 11 & 660 secs & - & - \\ \hline
    Level 12 & 720 secs & - & -\\ \hline
    Level 13 & 780 secs & - & - \\ \hline
    Level 14 & 840 secs & - & -\\ \hline
    Level 15 & 900 secs & -& -\\ \hline
    \end{tabular}
    \caption{The complete list of known energy efficiency levels across devices.}
	\label{table:energy_efficiency_levels}
\end{table}
	
To compare the performance of two sensors for a single device, the energy efficiency levels may be used. The sensor with a higher energy efficiency level has lower energy consumption. The energy efficiency levels may also provide the information about \textbf{the energy distance} between two sensors. If there is a known energy efficiency level between two sensors' levels, it may be reasoned that the difference in energy consumption is "significant". For example, if a sensor belongs to level 6 and another to level 8, the existence of a level 7\ (there is a sample with its corresponding value) may imply the sensors are not "closed enough". Finally, the energy efficiency levels are used as a normalization tool. The experiments' results, when represented as a level, could be shown on the same diagram (though they should not be compared). 
   
\subsubsection{Conclusions}   
\hspace{10pt} This implementation of Sensor energy measurements shows how important a role the mobile operating system plays in energy efficiency. There is evidence that Android's design decisions may significantly influence the battery depletion rate. For example, the Android operating system prioritises privacy over energy efficiency by requiring a camera capture preview. It was also shown how a badly designed API may reduce energy efficiency: Bluetooth Low Energy is an energy-efficient sensor, but its API drains battery by extraneous logging. This also raises the question of how energy-aware mobile operating systems' APIs should be.

This energy measurement method was successfully applied for the Google Nexus 7. It delivered 100\% valid samples, and may therefore be classified as a stable method. The method performed worse for the other two devices. The ideal initial battery percentage for the experiments needed to be manually customized and the method still delivered as many as 25\% of wrong samples. Those two facts eliminate the possibility of online energy measurements. Furthermore, the wrong samples were determined based on the whole set of conducted samples. This set is not available in online energy measurement. Even if possible to mitigate for online measurement, the method would be impractical as it requires collecting many samples to get accurate results.  

All samples delivered by the energy measurement method belonged to a small set of discrete values. Those values were further characterized by being multiples of some time interval. This observation was encapsulated by the idea of an energy efficiency level, which will be leveraged in further analysis of the results. 

\subsection{Locy}
No significant challenges occurred when implementing the primary requirements of the energy-efficient library, Locy. The parameters of the movement detection algorithm were established using a trial-and-error approach. Two sample applications were used to achieve it. Furthermore, inLocy was proposed as the extension of Locy. It also leverages movement detection for Wi-Fi based localization. Lastly, a prototype was implemented as a separate service. This approach may be leveraged to handle mobile applications contention. However, it also increases energy demands, and thus was not incorporated in Locy. The final version of the library is available in the \textit{locy/} directory. 

\subsubsection{Movement detection algorithm}
\label{s:implementation:moving}
\hspace{10pt} The Section \ref{s:design:locy:moving} described the movement detection algorithm. The parameters were chosen by trial-and-error. AN R script and the data set used for the trial-and-error approach can be found in the \textit{machine\_learning/movement\_detection} directory. The data set was collected over two activities: standing in one activity for 150 seconds\ (\textit{inPlace.csv} file) and walking also for 150 seconds\ (\textit{moving.csv} file). For most of the former activity, a mobile phone was either put on a desk in front of the user or kept in his front trousers pocket. Although the user occasionally moved his mobile phone or manually unlocked it, he did not move during the whole period\ (his geographical coordinates did not change). During the walking activity, the user kept his mobile phone in a trouser pocket or held it in front of him while walking constantly. The accelerometer data was collected by a sample application which can be found in the \textit{helpers/SensorsDataProducer} directory.

Once the parameters for the movement detection algorithm were established\ (the duration of the sampling window was 2.5 seconds and the threshold of movement classification 15), they were also tested on other mobile phones. The parameters were tested online by using the SensorsGraphPlotter application, which can be found in the \textit{helpers/SensorsGraphPlotter} directory. The application draws the graph of total magnitude of accelerometer data over time\ (\plotref{sensorsgraphplotter}). It updates its graph live over time.

\plot{sensorsgraphplotter}

\subsubsection{inLocy}
\hspace{10pt} inLocy is a variation of Locy servicing Wi-Fi based localization. Unlike Locy, there was no existing localization system available for testing. For inLocy, a simple Wi-Fi based localization system was mocked. The mock system receives the results of IEEE 802.11 scanning made by a device and checks whether the results contain a specific BSSID\ (\textit{9C:4E:20:C8:9E:71} - one of the access points available in the John Honey Building). If so, the user is localized as being in the John Honey building. The mock system is available to inLocy under \url{http://mk74.host.cs.st-andrews.ac.uk/locy/location.php}. The system's source code is available in the \textit{inLocyBackend/} directory. inLocy itself uses the same movement detection algorithm as Locy and its source code is available in the \textit{inLocy/} directory. However, inLocy is only a prototype, and thus serves as a single application and does not use duty-cycling. 

\subsubsection{Library as a service}
\hspace{10pt} One of the project's primary requirements\ (the Requirement \ref{r:library:contention}) was to manage mobile applications' contention for sensor usage\ (i.e. many applications concurrently using Locy in an energy-efficient manner). To fulfill this requirement, the state of the library must be shared across applications. The state is not shared if Locy is added to the project as a library\ (as in the current version of Locy). The state can be shared by defining Locy as a separate application, running as a background service. The application should be set to automatically start with the Android operating system\ (i.e. \textit{BOOT\_COMPLETED} intent action) and use Inter Process Communication\ (IPC) mechanisms to provide localization services to mobile applications. Although this should result in energy savings, the preliminary evaluation showed unpromising results. Implementation of IPC mechanisms in Locy would likely not be energy-efficient, but more work needs to be conducted to verify the result. Because of its high energy consumption, the feature is not in the final version of the library. The feature is nevertheless available in the \textit{locy\_as\_a\_service} branch of the repository.

\subsection{Conclusions}
\hspace{10pt} The implementation of sensor energy measurements illustrates the crucial importance of the software layer in the energy efficiency of mobile phones. It was proven that some of Android design decisions result in rapid battery depletion. Additionally, the energy measurement method indicates specific characteristics of a device's battery life. Some samples were wrong due to bursty errors and error-prone sensors. Similarly, the valid samples' values seemed to cluster around a small set of discrete values\ (energy efficiency levels). Those levels are utilized for further analysis in the next section. Although the method is stable, it cannot be applied as an online energy measurement tool\ (the Requirement \ref{r:measurement:online}). For older batteries, the method requires many samples, making the method impractical.

Since most of the challenges were discovered during the implementation of the Sample Sensor Applications, there were no significant difficulties with the implementation of Locy. The details of how the parameters of the movement detection algorithm were derived were explained. inLocy, a variation of the library, was also proposed. It showed that it is possible to use Wi-Fi based localization instead of GPS. Lastly, Locy was also prototyped to work as a separate background service. Although it deals with application's contention for sensor usage the prototype had a higher energy consumption. 
