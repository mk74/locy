\section{Implementation}
\label{s:implementation}
\hspace{10pt} This section describes the implementation of the experiments and the software components involved in the project. The implementation raises practical challenges, which results in revisiting the design presented in the previous section. The first part of this section summarizes the challenges in establishing the energy efficiency of sensors. After software and hardware problems are described, the characteristics of experiments' results are investigated. In that part, new terms: "wrong samples" and "energy efficiency levels" are defined. 


//The second subsection presents the implementation details of the energy efficient sensing library, Locy. [XXX keep going here on Locy + rewrite next sentence]. As a result of the implementation process, the conclusions on energy-accuracy of phone sensing are derived and presented in the last subsection.

\subsection{Sensor energy measurements}
There are two groups of challenges in the implementation of the experiments' design. First, Android operating system and its API affects the experiments' design. A couple of those issues\ (IEEE802.11 scanning, Bluetooth Low Energy API and privacy policy for video capturing) is described later. Second, there are many devices involved in the experiments. There are hardware differences between those mobile phones, which poses some challenges. The specification of the mobile phones involved in the experiments are presented in Table \ref{table:devices_differences}.
	
\begin{table}[H]
	\centering
    \begin{tabular}{| l | c | c | c |}
    \hline
      & \textbf{Google Nexus 7} & \textbf{HTC Flyer} & \textbf{HTC desire}\TBstrut  \\ \hline  
    Android & 4.3 & 3.3 &  2.3.3\TBstrut \\ \hline
  	CPU & Quad-core 1.2 GHz Cortex-A9 & 1.5 GHz Scorpion & 1 GHz Scorpion\TBstrut \\ \hline
  	Memory & 1 GB RAM & 1 GB RAM & 576 MB RAM\TBstrut \\ \hline
    Battery & Li-Ion 4325 mAh & Li-Po 4000 mAh & Li-Ion 1400 mAh\TBstrut \\ \hline
    Camera & \checkmark & \checkmark & \checkmark \\ \hline
    Microphone & \checkmark & \checkmark & \checkmark \\\hline
    IEEE 802.11 & \checkmark & \checkmark & \checkmark \\ \hline
    GPS & \checkmark & \checkmark & \checkmark \\ \hline
    Bluetooth & \checkmark & \checkmark & \checkmark\\ \hline
    Bluetooth LTE & \checkmark & - & - \\ \hline
    Accelerometer & \checkmark & \checkmark & \checkmark\\ \hline
    Gyroscope & \checkmark & - & -\\ \hline
    Magnetic Field & \checkmark & \checkmark & \checkmark\\ \hline
    Ambient Light & \checkmark & \checkmark & \checkmark\\ \hline
    Proximity & - & -& \checkmark\\ \hline
    \end{tabular}
    \caption{The differences between mobile phones involved in the experiments.}
	\label{table:devices_differences}
\end{table}	

Additionally, there are two other challenges in the experiments' results: some of the results are perceived as being invalid\ (defined as "wrong samples") and the valid results tend to have specific properties, which may be defined as "energy efficiency levels".

\subsubsection{Software problems}
\hspace{10pt} Preliminary experiments showed that \textbf{Wi-Fi scanning} was more energy-efficient than accelerometer. This was unexpected and the details of IEEE 802.11 scanning were further investigated. Unlike other sensors, IEEE 802.11 has many scanning parameters: active or passive; power save mode or not; caching scanning results, complete scanning etc. Those parameters are not stated in the Android documentation. Since they could affect the energy efficiency of IEEE 802.11 observed in the preliminary experiments, those parameters must have been determined. The results of IEEE 802.11 scanning on a mobile phone were compared with the ones obtained on the laptop. Kismac \cite{kismac:kismac} was used on the laptop to achieve the detailed list of access points with their signal strengths. Both scanning results were compared while a user is in place and moving. The parameters of IEEE 802.11 scanning on a mobile phone turned out to be identical to ones on the laptop. No caching scheme, no other energy optimization was involved\ (table \ref{table:wifiparameters}). It turned out that preliminary experiments of Wi-Fi scanning were correct. Since there was a problem in the experiments with accelerometer, Wi-Fi scanning seemed to be more energy-efficient. After fixing the problem, Wi-Fi scanning was less energy-efficient than accelerometer. As a side note, it is worth noticing that active IEEE 802.11 scanning is deprecated in Android API. Passive scanning is more energy efficient than active scanning, since radio reception\ (passive scanning) usually requires 10 times less power than radio transmission\ (active scanning).

\begin{table}[H]
\centering
    \begin{tabular}{| l | c |}
    \hline
    	Characteristic & Value \\ \hline
    	Scanning mode & Passive \\ \hline
    	Power save mode & No \\ \hline
    	Caching & No \\ \hline
    	Complete scanning & Yes \\ \hline
    \end{tabular}
    \caption{The parameters of IEEE 802.11 scanning. Those parameters are usual: no specific energy optimization is involved.}
	\label{table:wifiparameters}
\end{table}

The energy efficiency may not be the highest priority in the Android design. To make accurate energy efficiency comparisons, Wi-Fi connectivity needs to be completely disabled\ (except for Wi-Fi sensor application). Disabling wireless connectivity in the main settings is not sufficient. Android may switch Wi-Fi connectivity on at any point if it is required by \textbf{Google Location Service}. To undertake valid experiments, Google Location Service has to be also disabled\ (\plotref{android_advanced_wifi}). 

\plot{android_advanced_wifi}

Another software issue is \textbf{Bluetooth Low Energy\ (LE) API}. Bluetooth LE was designed to reduce power demands while providing the same functionality as Classic Bluetooth. Therefore, Classic Bluetooth scanning on Android is expected to be less energy-efficient that Bluetooth LE one. However, Bluetooth LE API is new\ (added in Android 18) and still under the development. In its current version\ (Android 18),  it prints out a lot of information to log file if any device is found. This leads to faster battery depletion than in case of Classic Bluetooth. If there is no device found, Bluetooth LE is more energy efficient than Classic Bluetooth. This phenomenon was further analyzed in the evaluation section \plotref{bluetooth_le_api}. 

Lastly, Android imposes its \textbf{privacy policy on video capturing} applications. The video applications are required to provide camera preview in order customers to be aware of recording. This privacy policy results in higher energy demands, since camera preview requires additional computational power\ (rendering the video capture). As Android API says, the camera preview has been added to the Camera Sensor Application.
		
\subsubsection{Hardware problems}
\hspace{10pt} Since modern mobile phones\ (e.g., Google Nexus 7) have energy-efficient hardware, \textbf{the time of 1\% battery depletion may be significant}. A test application keeps continuously sensing accelerometer and does not perform any other operations\ (screen was switched off, Wi-Fi connectivity was off). On Google Nexus 7, such an application would take around half an hour to deplete 1\% of battery life. Since online energy measurements \ref{o:measurements:online} are one of the project's objectives, the measurement method is expected to be faster. This could be achieved by adding additional energy demands to all Sample Sensor Applications. Those demands could be generated by complex computations (dividing big numbers), but the result of those computations would not be used by an application. However, such approach could invalidate out experiments, since different Sample Sensor Applications make use of CPU power to different extent.  Sample Sensor Application which uses more CPU (e.g., triangulation for GPS) may be more deeply affected by those computation demands (e.g., CPU scheduling). The simple solution to this problem is \textbf{keeping the screen always on} for the applications.  This not only significantly increases energy demands of each of the Sample Sensor Applications, but can also be uniformly added to each of them without invalidating the experiments. On Google Nexus 7, this operation has reduced the time of 1\% battery depletion for continuous accelerometer sensing to around 13 minutes\ (56\% shorter). 

Another hardware issue is \textbf{choosing a battery percentage} for the experiments\ (Table \ref{table:differentpercentage}). In case of Google Nexus 7, battery behavior is stable and repetitive for any chosen percentage. To reduce time of full cycle of obtaining experiment's sample (charging and discharging battery),  the percentage between 98\% and 99\% was chosen. The same percentage could not be chosen for other devices, since their batteries were old and less-stable e.g., 98\% -99\% percentage was tested for HTC Flyer, but the results were not repetitive. The percentages for other devices were found by \textbf{trial-and-error approach}. If the results of the experiments conducted on a given percentage were repetitive in a couple of trails , then the percentage was considered to be suitable for the experiments. Also, some specific characteristics of batteries charging cycles were discovered. For HTC Flyer, charging was much slower for the last percentage of the battery\ (99\%-100\%) than for any other percentages. Charging was much slower for the last percentage of the battery\ (99\%-100\%) than for any other percentages. After being fully charged, the battery depleted much slower for the last percentage\ (99\%-100\%). Then, the depletion of the battery between 98\% and 99\% was immediate.  This phenomenon was observed a few times. To avoid it, the percentage between 97\% and 98\% was tried and turned out to be suitable for the experiments on HTC Flyer. In case of HTC Desire, the charging was often not triggered while the battery level was more than 91\%. To mitigate this issue, I decided to test the percentage from 89\% to 88\% for HTC Desire. The experiments' results were repetitive and the percentage suitable for the experiments. 

\begin{table}[H]
\centering
    \begin{tabular}{| l | c |}
    \hline
    	Device & The percentage \\ \hline
    	Google Nexus 7 & 98\%-99\% \\ \hline
    	HTC Flyer & 97\%-98\% \\ \hline
    	HTC Desire & 88\%-89\% \\ \hline
    \end{tabular}
    \caption{The percentages used for energy measurement method. Those percentages are different for the devices and were found by trial-and-error approach.}
	\label{table:differentpercentage}
\end{table}

\textbf{HTC Desire has less dynamic memory}\ (576 MB RAM) than other devices\ (1 GB RAM) involved in the experiments. This affects the Camera Sensor Application. Initially, the experiment with video capturing could not be completed for HTC Desire, as there was no enough dynamic memory to encode and save the full video capture.  To alleviate this problem, the codecs were changed to H.263\ (it uses less dynamic memory for video encoding) and the video dimensions were reduced\ (less data needs to be encoded). Those parameters were standardized in the Camera Sensor Application across all devices. Because of consistency, the audio parameters were also standardized in the Microphone Sensor Applications for all mobile phones. Full details on video and audio capture's parameters are available in Appendices \ref{s:mediacodecs}.
			
\subsubsection{Invalid samples}
\hspace{10pt} Although many problems with the experiments executions have been diagnosed and mitigated, the method still delivers invalid samples. In statistics sense, the invalid samples are defined as experiments samples whose values\ (time measurements) are \textbf{outliers}.  The proportion of the invalid samples varies among devices\ (\plotref{devices_failed_samples}). Google Nexus 7 has 100\% of successful samples. The sample results are always valid, and therefore, the experiments are conducted up to \textbf{3 successful samples per sensor}. Other devices are characterized by higher proportion of invalid samples: between 20 and 30 percentages for HTC Flyer and HTC Desire. Because of that, \textbf{5 successful samples per sensor} has to be collected to complete the experiments for those devices. Also, the invalid samples have different characteristics for HTC Flyer and HTC Desire. 

\plot{devices_failed_samples}
	
The invalid samples for HTC Flyer may be characterized as \textbf{bursty errors}. The \plotref{htc_flyer_bursty_error} shows that most of invalid samples\ (9 out of 11) are grouped in two periods: 9-13 samples and 24-33. The first period includes continuous series of 4 invalid samples, whereas the second period has 6 invalid samples within 11 samples made. Each group has different characteristics, and thus, the bursty errors are difficult to detect without knowing complete experiments results\ (i.e. in online energy measurements).

\plot{htc_flyer_bursty_error}

For HTC Desire, the proportion of the invalid samples varies depending on a sensor\ (\plotref{htc_desire_failed_samples}). Some sensors such as "plain run", Bluetooth, GPS or Camera always provide successful samples. On the other hand, light and proximity sensors are characterized by high proportion of the invalid samples\ (each around 60\%). 

\plot{htc_desire_failed_samples}


\subsubsection{Energy efficiency levels}
\hspace{10pt} After rounding valid samples' time measurements to 10 seconds, it could be noticed that all measurements belong to specific set of discrete values. For HTC Flyer, there are only three such values: 210, 240 and 270 seconds\ (Table \ref{table:discretevalues}). Those values are every 30 seconds. To simplify the valid samples' time measurements, they can be divided by this interval\ (30 seconds). I define the results of this operation as \textbf{energy efficiency levels}. For HTC Flyer, there will be three energy efficiency levels: 7, 8 and 9. A result of any experiment sample belongs to one of those levels. 
			
\begin{table}[H]
\centering
    \begin{tabular}{| c | c |}
    \hline
    	Value & Samples \\ \hline
    	210 & 4 \\ \hline
    	240 & 22 \\ \hline
    	270 & 19 \\ \hline
    	Others & 0 \\ \hline
    \end{tabular}
    \caption{The values of energy measurement results for HTC Flyer. There are only 3 discrete values among all samples' results.}
	\label{table:discretevalues}
\end{table}
			
Analogically for HTC Desire, all valid sample's results belong to set of three numbers: 150, 200 and 250 seconds. As the interval between them equals to 50, the energy efficiency levels will be 3, 4 and 5. Lastly for Google Nexus 7, there are 9 discrete values among the all experiments results. Each of this value is a multiplication of 60 seconds. Respectively, initial discrete values are divided by 60 to establish energy efficiency levels. The full list of all known energy efficiency levels among devices is shown in Table \ref{table:energy_efficiency_levels}.
		
	
\begin{table}[H]
\centering
    \begin{tabular}{| c | c | c | c |}
    \hline
      Energy efficiency level & Google Nexus 7 & HTC Flyer & HTC desire \\ \hline
    Level 1 & -& - &  -\\ \hline
  	Level 2 & - & - & -\\ \hline
  	Level 3 & - & - & 150 secs\\ \hline
    Level 4 & 240 secs & - & 200 secs\\ \hline
    Level 5 & 300 secs & - & 250 secs \\ \hline
    Level 6 & - & - & - \\\hline
    Level 7 & - & 210 secs & - \\ \hline
    Level 8 & 480 secs & 240  secs & - \\ \hline
    Level 9 & 540 secs & 270 secs & - \\ \hline
    Level 10 & - & - & - \\ \hline
    Level 11 & 660 secs & - & - \\ \hline
    Level 12 & 720 secs & - & -\\ \hline
    Level 13 & 780 secs & - & - \\ \hline
    Level 14 & 840 secs & - & -\\ \hline
    Level 15 & 900 secs & -& -\\ \hline
    \end{tabular}
    \caption{The complete list of known energy efficiency levels across different devices.}
	\label{table:energy_efficiency_levels}
\end{table}
	
To compare the performance two sensors for a single device, the energy efficiency levels may be used. The sensor with higher energy efficiency level has lower energy consumption. The energy efficiency levels may also provide the information about \textbf{the energy distance} between two sensors. If there is a known energy efficiency level between two sensors' levels, it may be reasoned that the difference in energy consumption is "significant". For example, first sensor belongs to level 6 and another sensor belong to level 8. If the existence of level 7 is confirmed\ (there is a sample with its corresponding value), it could be stated that sensors are not "closed enough". Finally, the energy efficiency levels are used as a normalization tool. The experiments' results when represented as the level, could be shown on the same diagram (though they should not be compared). 

   
\subsubsection{Conclusions}   
\hspace{10pt} The implementation of Sensor energy measurements shows how important role the mobile operating system plays in energy efficiency. It was evidenced that Android design decision may significantly influence the pace of battery depletion. For example, camera preview is required for video capturing as privacy was decided to be more important than energy efficiency. It was also shown how badly designed API may reduce energy efficiency. Bluetooth Low Energy is energy-efficient sensor, but its API drains the battery life much. This also raises the question of how energy aware mobile operating API should be.

The energy measurement method was successfully applied for Google Nexus 7. It delivered 100\% of valid samples, and therefore, it may be classified as a stable method. The method did not perform so well for other two devices. The percentage for the experiments needed to be manually customized and the method still delivered as much as 25\% of invalid samples. Those two facts eliminates the possibility of online energy measurements. Furthermore, the invalid samples are determined basing on the whole set of conducted samples. This set is not available in online energy measurement. Even if it possible to mitigate those problems for online energy measurements, the method would be impractical as it requires collecting many samples to get accurate results.  

All samples delivered by the energy measurement method belong to the small set of discrete values. Those values are further characterized by being a multiplication of some time interval. This observation is encapsulated in the energy efficiency levels, which will be leveraged for further analysis. 

\subsection{Locy}
There were no significant challenges occurred while implementing the primary requirements of the energy-efficient library, Locy. The parameters of the moving detection algorithm were established using the trial-and-error approach. Two sample applications were used to achieve it. Furthermore, inLocy was proposed as the extension of Locy. It also leverages moving detection for Wi-Fi based localization. Lastly, a prototype was implemented as a separate service. This approach may be leveraged to handle mobile applications contention. However, it also increases energy demands, and thus, it was not incorporated in Locy. The final version of the library is available in the \textit{locy/} directory. 

\subsubsection{Moving detection algorithm}
\label{s:implementation:moving}
\hspace{10pt} The Section \ref{s:design:locy:moving} described the moving detection algorithm. The parameters were chosen by the trial-and-error approach. R script and the data set used for the trial-and-error approach can be found in the \textit{machine\_learning/movement\_detection} directory. The data set was collected over two activities: standing in one activity for 150 seconds\ (\textit{inPlace.csv} file) and walking also for 150 seconds\ (\textit{moving.csv} file). For most of the former activity, a mobile phone was either put on a desk in front of a user or kept in his front trousers pocket. Although a user occasionally moved his mobile phone or manually unlock it, he did not move during the whole period\ (his geographical position did not change). During the walking activity, a user kept his mobile phone in trousers pocket or held his mobile phone in front of him while walking all the time. The accelerometer data was collected by a sample application which can be found in the \textit{helpers/SensorsDataProducer} directory.

Once the parameters for the moving detection algorithm were established\ (the duration of sampling window equaled to 2.5 seconds and the threshold of movement classification equaled to 15). They were also tested on other mobile phones. Those parameters were tested online by using SensorsGraphPlotter application, which could be found in the \textit{helpers/SensorsGraphPlotter} directory. The application draws the graph of the total magnitude of accelerometer data over time\ (\plotref{sensorsgraphplotter}). It updates its graph live while time is passing.

\plot{sensorsgraphplotter}

\subsubsection{inLocy}
inLocy is a variation of Locy, which services Wi-Fi based localization. Unlike Locy, there was no ready localization system available for testing. For the purpose of inLocy, a simple Wi-Fi based localization system was mocked. The mock system receives the results of IEEE 802.11 scanning made by a device. It checks whether the results contain a specific BSSID\ (i.e. \textit{9C:4E:20:C8:9E:71} - one of the access points available in Josh Honey Building). If so, a user is localized as being in the Josh Honey building. The mock system is available to inLocy under \url{http://mk74.host.cs.st-andrews.ac.uk/locy/location.php}. The source of the system is available in the \textit{inLocyBackend/} directory. inLocy itself uses the same movement detection algorithm as Locy and its source code is available in \textit{inLocy/} directory. However, inLocy is only prototype, and thus, it serves as a single application and it also does not leverage duty-cycling for its purposes. 

\subsubsection{Library as a service}
One of the project's primary requirements\ (XXX ref requirement) was to manage mobile application's contention for sensor usage\ (i.e. many applications using Locy at the same time in energy-efficient manner). To fulfill this requirement, the state of the library must be shared across many applications. The state is not shared if Locy is added to the project as a library\ (the current version of Locy). The state can be shared by defining Locy as a separate application, which runs its own background service. The application should be triggered at the start of Android operating system\ (\textit{BOOT_COMPLETED} intent action) and use Inter Process Communication\ (IPC) mechanisms to provide localization services to mobile applications. Although the approach should result in energy savings, the preliminary evaluation did not show the promising results. It is likely that the implementation of IPC mechanisms in Locy is not energy-efficient. More work needs to be conducted to verify it. Because of its high energy consumption, the feature is not plugged into the final version of the library. The feature is available in the \texit{locy_as_a_service} branch of the repository.

\subsection{Conclusions}
The implementation of sensor energy measurements indicated the crucial importance of software layer in energy efficiency. It was proven that some of Android design decisions result in fast battery depletion. Furthermore, the energy measurement method indicated characteristics of battery lifes. Invalid samples among devices were a result of different phenomenons\ (bursty errors and error-prone sensors). Similarly, the results of valid samples seem to have a pattern\ (energy efficiency levels), which will be leveraged in further analysis. Although the method is stable, it cannot be applied as online energy measurement tool. For older batteries, the method requires many samples, which makes it impractical.

Locy XXX...
	-most challenges identified while implementing sample sensor application
	-however things got more complex while more software is involved
		-some aims could not be achieved
			-wifi-based localizaiton
			-library as a service