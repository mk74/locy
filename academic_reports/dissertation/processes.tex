\section{Software engineering processes}
\label{s:processes}
\hspace{10pt} Besides Dr Tristan Henderson being my supervisor, he also acted as \textbf{a fictional customer} of my software product. The continuous client contact allowed us to apply an \textbf{Agile} approach. At the beginning of our cooperation, we established what we want to achieve (objectives) and how to measure whether we have achieved them (requirements). During the project, we used those requirements to indicate whether we are on track to finish the product on time.

We applied \textbf{Test-Driven Development}: every week, I tested and implemented a next block of the final product. Then, I documented my progress\ (all progress files are available in \textit{progress/} directory) and met with Tristan. He provided me with continuous feedback on my work and assessed whether I met last week's aims. At the end of each of these meetings, we set goals for the next week. This approach was suitable for \textbf{a research project}, as it was often difficult to estimate the time I would need to complete each part of the project. Some of our objectives were new to the research community and so we simply did not even know whether they were possible. Energy-efficient sensing is a very complex subject, so a different software engineering process might have introduced a risk of not delivering the product on time. By making development cycles short and having continuous feedback, I could achieve the objectives set out at the beginning. For example, Locy went through a couple of phases. First, there were two applications: an application continuously sampling the GPS\ (baseline application) and another continuously sampling the accelerometer. These applications' energy efficiencies were compared. The latter had lower energy demands, and thus was evolved into its new form. The new form of the application switched on GPS when it inferred from motion detection that a user was not walking. After this was implemented, its energy efficiency was evaluated. The result was not so promising, and thus, duty-cycling was introduced. This was followed by another series of energy efficiency experiments. Finally, the application was refactored into a separate library, called Locy. Such development cycle shows how early testing (evaluating energy efficiency) has affected the project's design decisions.
			
For the development process, we also used a variety of support software. The code was hosted and shared between myself and Tristan by using Git, a popular source code management tool. Since the very beginning, the whole project\ (except for Tristan's ESM) was open-sourced and publicly available on GitHub: \url{https://github.com/mk74/locy}. We believed this would ensure higher code quality and attract other researchers who work on the same problem. All applications were created in Android Developer Tools \cite{google:adt}, a special plugin for Eclipse. Google's new Android IDE, Android Studio \cite{google:androidstudio} has interesting features specifically for Android development (e.g., code refactoring to run faster), but is still in beta. The testing of our library project involved energy measurement, which we couldn't automate, hence why no testing framework was used. Lastly, we used CiteULike for sharing and managing research papers and references for this document.
	
